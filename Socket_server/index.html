<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    Hello
    <script src="/tf.min.js"></script>
    <script src="/teachablemachine-image.min.js"></script>
    <script>
      let host = window.location.host;
      let socket;
      let reconnectInterval = 2000; // Time in milliseconds to wait before attempting to reconnect
      connect();
      function connect() {
        socket = new WebSocket("ws://" + host);

        socket.onopen = function () {
          console.log("Connected to server");
        };

        socket.onmessage = async function (event) {
          let msg = JSON.parse(event.data);
          console.log("Message from server:", msg);
          if (msg.data === "start") {
            console.log("Starting prediction");
            await init();
          }
        };

        socket.onclose = function () {
          console.log("Disconnected from server");
          // Attempt to reconnect
          setTimeout(connect, reconnectInterval);
        };

        socket.onerror = function (error) {
          console.error("WebSocket Error:", error);
          // Handle error, then attempt to reconnect
          setTimeout(connect, reconnectInterval);
        };
      }

      // Function to send JSON messages to the server
      function sendMessage(messageObject) {
        if (socket.readyState === WebSocket.OPEN) {
          let message = JSON.stringify(messageObject);
          socket.send(message);
          console.log("Message sent to server:", message);
        } else {
          console.log("WebSocket is not open. Ready state:", socket.readyState);
        }
      }

      const URL = "http://" + window.location.host;

      let model, maxPredictions;

      // Initialize and load the model
      async function init() {
        const modelURL = URL + "/model.json";
        const metadataURL = URL + "/metadata.json";

        try {
          // Load the model and metadata
          model = await tmImage.load(modelURL, metadataURL);
          maxPredictions = model.getTotalClasses();
          await predict();
        } catch (error) {
          console.error("Error loading model:", error);
        }
      }

      // Predict the image
      async function predict() {
        try {
          const image = await loadImageFromURL(URL + "/image.jpg");
          const prediction = await model.predict(image);
          let highestPrediction = 0;
          let highestClass = "";
          for (let i = 0; i < prediction.length; i++) {
            if (prediction[i].probability > highestPrediction) {
              highestPrediction = prediction[i].probability;
              highestClass = prediction[i].className;
            }
          }

          console.log(highestClass);
          sendMessage({ type: "prediction", data: highestClass });
        } catch (error) {
          console.error("Error predicting image:", error);
        }
      }

      // Load image from URL
      async function loadImageFromURL(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous"; // This may be required to avoid CORS issues
          img.onload = function () {
            resolve(img);
          };
          img.onerror = function () {
            reject(new Error("Failed to load image from URL"));
          };
          img.src = url;
        });
      }
    </script>
  </body>
</html>
